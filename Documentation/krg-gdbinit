define offset_of
	print &((struct $arg0 *) 0)->$arg1
end

define ps
	set $inittask = &init_task
	set $mthread = &init_task
	set $tasks_off = (size_t)&((struct task_struct*) 0)->tasks
	set $thread_group_off = (size_t)&((struct task_struct*) 0)->thread_group
	set $cont = 1
	while $cont == 1
		set $athread = $mthread
		set $subcont = 1
		while $subcont == 1
			printf "%d %s\n", $athread->pid, (char*)$athread->comm
			if (int)$athread->thread_group.next == 0
				set $subcont = 0
			else
				set $athread = (struct task_struct*)((char*)$athread->thread_group.next-$thread_group_off)
				if $athread == $mthread
					set $subcont = 0
				end
			end
		end
		set $mthread = (struct task_struct*)((char*)$mthread->tasks.next-$tasks_off)
		if $mthread == $inittask
			set $cont = 0
		end
	end
end
document ps
	list all threads and processes in the system
end

define dmesg
	set $i = 0
	set $end_idx = (log_end - 1) & (log_buf_len - 1)

	while ($i < logged_chars)
		set $idx = (log_end - 1 - logged_chars + $i) & (log_buf_len - 1)

		if ($idx + 100 <= $end_idx) || \
		   ($end_idx <= $idx && $idx + 100 < log_buf_len)
			printf "%.100s", &log_buf[$idx]
			set $i = $i + 100
		else
			printf "%c", log_buf[$idx]
			set $i = $i + 1
		end
	end
end
document dmesg
	print the kernel ring buffer
end
