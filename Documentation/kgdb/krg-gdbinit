define __offset_of
	print &(($arg0 *) 0)->$arg1
end

define offset_of
	print &((struct $arg0 *) 0)->$arg1
end

define __container_of
	print ($arg1 *)(((char *)$arg0) - (char *)&(($arg1 *) 0)->$arg2)
end

define container_of
	print (struct $arg1 *)(((char *)$arg0) - (char *)&((struct $arg1 *) 0)->$arg2)
end

define __attach
	target extended-remote udp:$arg0:6443
end

define attach
	__attach 10.4.7.$arg0
end

define reboot
	run
end

define ps
	set $inittask = &init_task
	set $mthread = &init_task
	set $tasks_off = (size_t)&((struct task_struct*) 0)->tasks
	set $thread_group_off = (size_t)&((struct task_struct*) 0)->thread_group
	set $cont = 1
	while $cont == 1
		set $athread = $mthread
		set $subcont = 1
		while $subcont == 1
			printf "%d %s\n", $athread->pid, (char*)$athread->comm
			if (int)$athread->thread_group.next == 0
				set $subcont = 0
			else
				set $athread = (struct task_struct*)((char*)$athread->thread_group.next-$thread_group_off)
				if $athread == $mthread
					set $subcont = 0
				end
			end
		end
		set $mthread = (struct task_struct*)((char*)$mthread->tasks.next-$tasks_off)
		if $mthread == $inittask
			set $cont = 0
		end
	end
end
document ps
	list all threads and processes in the system
end

define dmesg
	set $i = 0
	set $end_idx = (log_end - 1) & (log_buf_len - 1)

	while ($i < logged_chars)
		set $idx = (log_end - 1 - logged_chars + $i) & (log_buf_len - 1)

		if ($idx + 100 <= $end_idx) || \
		   ($end_idx <= $idx && $idx + 100 < log_buf_len)
			printf "%.100s", &log_buf[$idx]
			set $i = $i + 100
		else
			printf "%c", log_buf[$idx]
			set $i = $i + 1
		end
	end
end
document dmesg
	print the kernel ring buffer
end

define __task_pids
	set $pid = $arg1->pids[PIDTYPE_PID].pid
	set $max_level = $pid->level
	set $level = 0

	while $level <= $max_level
		printf "level %d:\t", $level
		p $pid->numbers[$level].nr
		set $level = $level + 1
	end
end

define task_pids
	__task_pids "" $arg0
end
document task_pids
	print pids in all namespaces (starting from init_pid_ns) of a task given its address
end

define task
	set $t = (struct task_struct *) $arg0

	printf "Task "
	p $t->pid

	printf "  comm:\t"
	p $t->comm

	printf "  pids:\n"
	__task_pids "    " $t

	printf "  task_struct:\t"
	p $t

	printf "  stack:\t"
	p $t->stack

	printf "  signal:\t"
	p $t->signal

	printf "  sighand:\t"
	p $t->sighand

	printf "  mm:\t\t"
	p $t->mm

	printf "  files:\t"
	p $t->files

	printf "  fs:\t\t"
	p $t->fs

	printf "  state:\t"
	p /x $t->state

	printf "  flags:\t"
	p /x $t->flags
end
document task
	print informations on a task given its task_struct address
end

define __taskpid
	set $nr = $arg0
	set $ns = $arg1
	set $level = $ns->level
	set $s = pidhash_shift
	set $hash = (unsigned long)$nr + (unsigned long)$ns
	set $n = $hash

	set $n <<= 18
	set $hash -= $n
	set $n <<= 33
	set $hash -= $n
	set $n <<= 3
	set $hash += $n
	set $n <<= 3
	set $hash -= $n
	set $n <<= 4
	set $hash += $n
	set $n <<= 2
	set $hash += $n

	set $hash >>= (64 - $s)

	set $pos = pid_hash[$hash].first
	while $pos != 0
		set $upid = (struct upid *)((char *)$pos - (char *)&((struct upid *)0)->pid_chain)
		if $upid->nr == $nr && $upid->ns == $ns
			set $pid = (struct pid *)((char *)$upid - (char *)&(((struct pid *)0)->numbers[$level]))
			loop_break
		end

		set $pos = $pos->next
	end

	set $t = 0
	if $pos != 0
		set $t = $pid->tasks[0].first
		if $t != 0
			set $t = (struct task_struct *)((char *)$t - (char *)&((struct task_struct *)0)->pids[0].node)
		end
	end

	if $t == 0
		printf "no such task\n"
	else
		task $t
	end
end
document __taskpid
	print informations on a task given its pid and a pid namespace
end

define taskpid
	__taskpid $arg0 &init_pid_ns
end
document taskpid
	print informations on a task given its pid
end

define taskkpid
	if krg_ns == 0
		printf "no Kerrighed namespace\n"
	else
		__taskpid $arg0 krg_ns->root_pid_ns
	end
end
document taskkpid
	print informations on a task given its Kerrighed pid
end
